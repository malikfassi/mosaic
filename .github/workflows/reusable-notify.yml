name: Notify Status

on:
  workflow_call:
    inputs:
      execution_plan:
        required: true
        type: string
      frontend_ci_result:
        required: true
        type: string
      mosaic_tile_ci_result:
        required: true
        type: string
      mosaic_vending_ci_result:
        required: true
        type: string
      mosaic_tile_deploy_result:
        required: true
        type: string
      mosaic_vending_deploy_result:
        required: true
        type: string
      mosaic_tile_e2e_result:
        required: true
        type: string
      mosaic_vending_e2e_result:
        required: true
        type: string
      full_e2e_result:
        required: true
        type: string
    secrets:
      DISCORD_WEBHOOK:
        required: true
      GIST_TOKEN:
        required: true

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Generate Status Message
        id: status
        run: |
          # Parse execution plan
          plan='${{ inputs.execution_plan }}'
          
          # Function to format component status
          format_component_status() {
            local name=$1
            local component=$(echo "$plan" | jq -r ".components.$name")
            local hash=$(echo "$component" | jq -r '.hash')
            local files_changed=$(echo "$component" | jq -r '.files_changed')
            local previous_run=$(echo "$component" | jq -r '.previous_run')
            local has_previous=$(echo "$previous_run" | jq -r '.found')
            
            # Get changed files directly from the execution plan
            local changed_files=""
            if [[ "$files_changed" == "true" ]]; then
              changed_files=$(echo "$component" | jq -r '.changed_files | .[] | "  - " + . + "\n"')
              if [[ -n "$changed_files" ]]; then
                changed_files="\nChanged files:\n\`\`\`\n$changed_files\`\`\`"
              fi
            fi
            
            if [[ "$files_changed" == "true" ]]; then
              echo "üîÑ Changes detected$changed_files"
            elif [[ "$has_previous" == "true" ]]; then
              local run=$(echo "$previous_run" | jq -r '.run')
              local run_url=$(echo "$run" | jq -r '.url')
              local created_at=$(echo "$run" | jq -r '.created_at')
              echo "‚úÖ No changes (last success: $created_at - $run_url)"
            else
              echo "üÜï First run with this hash"
            fi
          }
          
          # Function to format job result
          format_job_result() {
            local job_name=$1
            local current_result=$2
            
            # Get job info from execution plan
            local job=$(echo "$plan" | jq -r ".jobs[\"$job_name\"]")
            local needs_run=$(echo "$job" | jq -r '.needs_run')
            local previous_result=$(echo "$job" | jq -r '.previous_result')
            local previous_deps=$(echo "$job" | jq -r '.previous_dependency_results')
            
            # Format current result
            local result_emoji
            case "$current_result" in
              "success") result_emoji="‚úÖ";;
              "failure") result_emoji="‚ùå";;
              "cancelled") result_emoji="‚ö™";;
              "skipped") result_emoji="‚è≠Ô∏è";;
              *) result_emoji="‚ùì";;
            esac
            
            # Add previous result info if available
            local result_text="$result_emoji"
            if [[ "$needs_run" == "false" && "$previous_result" != "null" ]]; then
              # Get previous run info
              local component_name=$(echo "$job" | jq -r '.component')
              if [[ "$component_name" != "null" ]]; then
                local previous_run=$(echo "$plan" | jq -r ".components.$component_name.previous_run.run")
                if [[ "$previous_run" != "null" ]]; then
                  local run_url=$(echo "$previous_run" | jq -r '.url')
                  local run_date=$(echo "$previous_run" | jq -r '.created_at' | cut -d'T' -f1)
                  result_text+=" (reusing $run_date [run]($run_url))"
                fi
              fi
            fi
            
            # Add dependency results if any failed
            if [[ "$previous_deps" != "{}" ]]; then
              local failed_deps=$(echo "$previous_deps" | jq -r 'to_entries | map(select(.value != "success")) | map(.key) | join(", ")')
              if [[ -n "$failed_deps" ]]; then
                result_text+="\n‚ö†Ô∏è Previous run had failed dependencies: $failed_deps"
              fi
            fi
            
            echo "$result_text"
          }
          
          # Function to format component hash info
          format_hash_info() {
            local name=$1
            local component=$(echo "$plan" | jq -r ".components.$name")
            local current_hash=$(echo "$component" | jq -r '.hash')
            local previous_run=$(echo "$component" | jq -r '.previous_run')
            local has_previous=$(echo "$previous_run" | jq -r '.found')
            
            if [[ "$has_previous" == "true" ]]; then
              local previous_hash=$(curl -H "Authorization: token ${{ github.token }}" -L "$(echo "$previous_run" | jq -r '.run.url')" | jq -r ".components.$name.hash")
              if [[ "$current_hash" != "$previous_hash" ]]; then
                echo "\`$current_hash\` _(changed from \`$previous_hash\`)_"
              else
                echo "\`$current_hash\`"
              fi
            else
              echo "\`$current_hash\` _(new)_"
            fi
          }
          
          # Generate component sections
          frontend_status=$(format_component_status "frontend")
          mosaic_tile_status=$(format_component_status "mosaic_tile")
          mosaic_vending_status=$(format_component_status "mosaic_vending")
          
          # Generate hash info
          frontend_hash=$(format_hash_info "frontend")
          mosaic_tile_hash=$(format_hash_info "mosaic_tile")
          mosaic_vending_hash=$(format_hash_info "mosaic_vending")
          
          # Generate job results
          frontend_result=$(format_job_result "frontend-ci" "${{ inputs.frontend_ci_result }}")
          mosaic_tile_result=$(format_job_result "mosaic-tile-ci" "${{ inputs.mosaic_tile_ci_result }}")
          mosaic_vending_result=$(format_job_result "mosaic-vending-ci" "${{ inputs.mosaic_vending_ci_result }}")
          mosaic_tile_deploy_result=$(format_job_result "deploy-mosaic-tile" "${{ inputs.mosaic_tile_deploy_result }}")
          mosaic_vending_deploy_result=$(format_job_result "deploy-mosaic-vending" "${{ inputs.mosaic_vending_deploy_result }}")
          mosaic_tile_e2e_result=$(format_job_result "mosaic-tile-e2e" "${{ inputs.mosaic_tile_e2e_result }}")
          mosaic_vending_e2e_result=$(format_job_result "mosaic-vending-e2e" "${{ inputs.mosaic_vending_e2e_result }}")
          full_e2e_result=$(format_job_result "full-e2e" "${{ inputs.full_e2e_result }}")
          
          # Create message
          message="üöÄ **Workflow Run Report**
          
          **Components**
          
          **Frontend**
          Status: $frontend_status
          Hash: $frontend_hash
          
          **Mosaic Tile**
          Status: $mosaic_tile_status
          Hash: $mosaic_tile_hash
          
          **Mosaic Vending**
          Status: $mosaic_vending_status
          Hash: $mosaic_vending_hash
          
          **Jobs**
          
          **CI Jobs**
          Frontend CI: $frontend_result
          Mosaic Tile CI: $mosaic_tile_result
          Mosaic Vending CI: $mosaic_vending_result
          
          **Deploy Jobs**
          Mosaic Tile Deploy: $mosaic_tile_deploy_result
          Mosaic Vending Deploy: $mosaic_vending_deploy_result
          
          **E2E Jobs**
          Mosaic Tile E2E: $mosaic_tile_e2e_result
          Mosaic Vending E2E: $mosaic_vending_e2e_result
          Full E2E: $full_e2e_result
          
          **Run Details**
          Commit: \`$(echo "$plan" | jq -r '.metadata.commit_sha')\`
          Workflow: [#$(echo "$plan" | jq -r '.metadata.workflow_id')](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          Event: $(echo "$plan" | jq -r '.metadata.event_type')
          "
          
          # Save message
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$message" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send Discord Notification
        if: always()
        uses: Ilshidur/action-discord@master
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        with:
          args: ${{ steps.status.outputs.message }}

      - name: Create status file
        run: |
          echo "${{ steps.status.outputs.message }}" > status.md

      - name: Update Status Gist
        if: always()
        uses: fjogeleit/http-request-action@v1
        with:
          url: https://api.github.com/gists/${{ inputs.gist_id }}
          method: 'PATCH'
          bearerToken: ${{ secrets.GIST_TOKEN }}
          data: |
            {
              "files": {
                "status.md": {
                  "content": "${{ steps.status.outputs.message }}"
                }
              }
            }